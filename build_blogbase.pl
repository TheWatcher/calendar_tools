#!/usr/bin/perl

use strict;
use v5.12;

our ($scriptpath, $config);

# Work out where the script is running from
use FindBin;
BEGIN {
    $ENV{"PATH"} = "/bin:/usr/bin"; # safe path.

    # $FindBin::Bin is tainted by default, so we may need to fix that
    # NOTE: This may be a potential security risk, but the chances
    # are honestly pretty low...
    if ($FindBin::Bin =~ /(.*)/) {
        $scriptpath = $1;
    }
}

use lib qw(/var/www/webperl);
use Webperl::ConfigMicro;
use Webperl::Utils qw(path_join save_file);
use Webperl::Template;
use DateTime;
use HTML::WikiConverter;
use LWP::Authen::OAuth2;
use Data::Dumper;

use lib path_join($scriptpath, "modules");
use Emailer;
use Google::Calendar;

# =============================================================================
#  Google interaction code

## @fn void save_tokens($token)
# Save the tokens provided by Google to the configuration file. This is a
# callback used by the OAuth2 handler to support automated saving of the
# tokens provided by google.
#
# @param token The token string to save to the configuration file.
sub save_tokens {
    my $token = shift;

    $config -> {"google"} -> {"token"} = $token;
    $config -> write()
        or die "Unable to write configuration: ".$config -> errstr()."\n";
}


## @method get_events($calendar, $from, $days, $ids)
# Generate a hash containing events pulled from calendars with the specified ids
# from the given start date for a number of days.
#
# @param calendar A reference to a Google::Calendar object to fetch events through.
# @param from     The date to start fetching events from. Can either be a datestamp
#                 or an offset in days from the current day, or a day of the week.
#                 See Google::Calendar::request_events() for more information.
# @param days     The number of days of events to fetch.
# @param ids      A string containing the google calendar IDs to read events from.
#                 can either be a single ID string, or a comma separated list of
#                 calendar IDs.
# @return A reference to a hash containing the events, start, and end dates on
#         success. Dies on error.
sub get_events {
    my $calendar = shift;
    my $from     = shift;
    my $days     = shift;
    my $ids      = shift;

    my @idlist = split(/,/, $ids);

    my $allevents = {};
    foreach my $id (@idlist) {
        my $events = $calendar -> request_events_as_days($id, $days, $from)
            or die "Unable to read events for calendar $id: ".$calendar -> errstr()."\n";

        $calendar -> merge_day_events($allevents, $events);
    }

    return $allevents;
}


# =============================================================================
#  Event handling code

sub build_event_date {
    my $start  = shift;
    my $end    = shift;
    my $allday = shift;

    my $timestr = "";
    given(DateTime -> compare($start -> clone() -> truncate(to => 'day'), $end -> clone() -> truncate(to => 'day'))) {
        # Same day, possibly all day
        when(0) { $timestr = $start -> strftime("%A, %d %b, ");
                  if($allday) {
                      $timestr .= "all day";
                  } else {
                      $timestr .= ($start -> strftime("%I:%M%P")."-".$end -> strftime("%I:%M%P"));
                  }
        }

        # Multiday event
        when(-1) { $timestr = $start -> strftime("%A, %d %b, %I:%M%P")."-".$end -> strftime("%A, %d %b, %I:%M%P"); }

        # End day is before start?!
        when(1)  { print STDERR "End ($end) is before start ($start)\n";
        }
    }

    # Trim times
    $timestr =~ s/0(\d:)/$1/g;
    $timestr =~ s/:00//g;

    return $timestr;
}


# @fn $ events_to_string($events, $template, $detail_limit)
# Convert a hash of events into a string suitable to write to file. This goes
# through the events in the events hash, using the template engine to convert
# them to human-readable strings.
#
# @param events       A reference to a hash of events as generated by Google::Calendar::request_events_as_days()
# @param template     A reference to a Webperl::Template object
# @param detail_limit The number of days of events to include detailed information for.
# @return A string containing the events in human-readable form.
sub events_to_string {
    my $events       = shift;
    my $template     = shift;
    my $detail_limit = shift;
    my $ongoing  = "";
    my $upcoming = "";

    my $detail_end = $events -> {"reqstart"} -> clone() -> add(days => $detail_limit);
    foreach my $day (sort keys(%{$events -> {"days"}})) {
        my $dayevents = "";

        foreach my $event (@{$events -> {"days"} -> {$day} -> {"events"}}) {
            next unless($event -> {"colorId"});

            my $description = (DateTime -> compare($events -> {"days"} -> {$day} -> {"date"}, $detail_end) <= 0) ? $event -> {"description"} : "Description";
            my $date = build_event_date($event -> {"start"} -> {"DateTimeObj"}, $event -> {"end"} -> {"DateTimeObj"}, $event -> {"allday"});

            $dayevents .= $template -> load_template("blogbase/item.tem", {"***summary***"     => $event -> {"summary"},
                                                                           "***url***"         => $event -> {"htmlLink"},
                                                                           "***description***" => $description,
                                                                           "***date***"        => $date,
                                                                           "***location***"    => $event -> {"location"} });
        }

        # Add these day events to the appropriate list of events
        if(DateTime->compare($events -> {"days"} -> {$day} -> {"date"}, $events -> {"reqstart"}) < 0) {
            $ongoing .= $dayevents;
        } else {
            $upcoming .= $dayevents;
        }
    }

    $ongoing  = $template -> load_template("blogbase/ongoing.tem" , {"***ongoing***" => $ongoing}) if($ongoing);
    $upcoming = $template -> load_template("blogbase/upcoming.tem", {"***upcoming***" => $upcoming}) if($upcoming);

    return $template -> load_template("blogbase/container.tem", {"***ongoing***" => $ongoing,
                                                                 "***upcoming***" => $upcoming});
}


$config = Webperl::ConfigMicro -> new(path_join($scriptpath, "config", "site.cfg"), quote_values => '')
    or die "Unable to load configuration: ".$Webperl::SystemModule::errstr;

$config -> {"config"} -> {"base"} = $scriptpath;

my $agent = LWP::Authen::OAuth2->new(client_id        => $config -> {"google"} -> {"client_id"},
                                     client_secret    => $config -> {"google"} -> {"client_secret"},
                                     service_provider => "Google",
                                     redirect_uri     => $config -> {"google"} -> {"redirect_uri"},

                                     # Optional hook, but recommended.
                                     save_tokens      => \&save_tokens,

                                     # This is for when you have tokens from last time.
                                     token_string     => $config -> {"google"} -> {"token"},
                                     scope            => $config -> {"google"} -> {"scope"},

                                     flow => "web server",
                 );

my $calendar = Google::Calendar -> new(agent    => $agent,
                                       settings => $config)
    or die "Unable to create calendar object\n";

my $template = Webperl::Template -> new(settings => $config)
    or die "Unable to create template object\n";

my $events = "";
my $start  = DateTime -> now();
foreach my $section (keys %{$config}) {
    # Only interested in calendar sections
    next unless($section =~ /^calendar.\d+$/);

    my $day_events = get_events($calendar,
                                $config -> {"blogbase"} -> {"from"},
                                $config -> {"blogbase"} -> {"days"},
                                $config -> {$section} -> {"id"});

    $start = $day_events -> {"reqstart"};
    $events .= events_to_string($day_events, $template, $config -> {"blogbase"} -> {"detail_limit"});
}

my $filename = path_join($config -> {"blogbase"} -> {"filebase"}, "blogbase-".$start -> strftime("%Y-%m-%d").".txt");
save_file($filename, $events);
